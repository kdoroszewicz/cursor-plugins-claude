---
description: Best practices for handling Stripe webhooks — signature verification, idempotent processing, and event handling patterns
globs:
  - "**/webhook*.*"
  - "**/stripe*.*"
alwaysApply: false
---

# Stripe Webhook Handling Best Practices

## Always Verify Webhook Signatures

- **Every webhook endpoint must verify the signature** before processing the event. This prevents attackers from sending fake events to your endpoint.

```typescript
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

export async function handleWebhook(req: Request) {
  const sig = req.headers['stripe-signature']!;
  const body = await req.text(); // Must be the raw body, not parsed JSON

  let event: Stripe.Event;
  try {
    event = stripe.webhooks.constructEvent(
      body,
      sig,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (err) {
    console.error('Webhook signature verification failed:', err);
    return new Response('Webhook signature verification failed', { status: 400 });
  }

  // Process the verified event
  await processEvent(event);
  return new Response('OK', { status: 200 });
}
```

## Handle Events Idempotently

- **Stripe may send the same event multiple times.** Always check if you've already processed an event before taking action. Use the `event.id` as a deduplication key.

```typescript
async function processEvent(event: Stripe.Event) {
  // Check if event was already processed
  const existing = await db.webhookEvent.findUnique({
    where: { stripeEventId: event.id },
  });
  if (existing) {
    console.log(`Event ${event.id} already processed, skipping`);
    return;
  }

  // Process the event
  await handleEventByType(event);

  // Record that we processed this event
  await db.webhookEvent.create({
    data: {
      stripeEventId: event.id,
      type: event.type,
      processedAt: new Date(),
    },
  });
}
```

## Respond Quickly, Process Asynchronously

- **Return a 200 response immediately**, then process the event asynchronously. Stripe will retry if it doesn't receive a 2xx response within a timeout window.

```typescript
// ✅ Correct — respond first, process async
app.post('/webhooks/stripe', async (req, res) => {
  const event = stripe.webhooks.constructEvent(
    req.body, req.headers['stripe-signature']!, webhookSecret
  );

  // Acknowledge receipt immediately
  res.status(200).json({ received: true });

  // Process asynchronously (use a job queue in production)
  await processEventAsync(event).catch((err) => {
    console.error(`Error processing event ${event.id}:`, err);
  });
});

// ❌ Incorrect — don't do heavy processing before responding
app.post('/webhooks/stripe', async (req, res) => {
  const event = stripe.webhooks.constructEvent(...);
  await doHeavyProcessing(event); // Stripe may time out waiting
  res.status(200).json({ received: true });
});
```

## Critical Events to Handle

- **Always handle these essential webhook events** for a complete payment integration:

```typescript
async function handleEventByType(event: Stripe.Event) {
  switch (event.type) {
    // --- Checkout ---
    case 'checkout.session.completed': {
      const session = event.data.object as Stripe.Checkout.Session;
      await handleCheckoutCompleted(session);
      break;
    }
    case 'checkout.session.expired': {
      const session = event.data.object as Stripe.Checkout.Session;
      await handleCheckoutExpired(session);
      break;
    }

    // --- Invoices ---
    case 'invoice.paid': {
      const invoice = event.data.object as Stripe.Invoice;
      await handleInvoicePaid(invoice);
      break;
    }
    case 'invoice.payment_failed': {
      const invoice = event.data.object as Stripe.Invoice;
      await handleInvoicePaymentFailed(invoice);
      break;
    }
    case 'invoice.finalized': {
      const invoice = event.data.object as Stripe.Invoice;
      await handleInvoiceFinalized(invoice);
      break;
    }

    // --- Subscriptions ---
    case 'customer.subscription.created': {
      const subscription = event.data.object as Stripe.Subscription;
      await handleSubscriptionCreated(subscription);
      break;
    }
    case 'customer.subscription.updated': {
      const subscription = event.data.object as Stripe.Subscription;
      await handleSubscriptionUpdated(subscription);
      break;
    }
    case 'customer.subscription.deleted': {
      const subscription = event.data.object as Stripe.Subscription;
      await handleSubscriptionDeleted(subscription);
      break;
    }

    // --- Payment Intents ---
    case 'payment_intent.succeeded': {
      const paymentIntent = event.data.object as Stripe.PaymentIntent;
      await handlePaymentIntentSucceeded(paymentIntent);
      break;
    }
    case 'payment_intent.payment_failed': {
      const paymentIntent = event.data.object as Stripe.PaymentIntent;
      await handlePaymentIntentFailed(paymentIntent);
      break;
    }

    // --- Charges (refunds, disputes) ---
    case 'charge.refunded': {
      const charge = event.data.object as Stripe.Charge;
      await handleChargeRefunded(charge);
      break;
    }
    case 'charge.dispute.created': {
      const dispute = event.data.object as Stripe.Dispute;
      await handleDisputeCreated(dispute);
      break;
    }

    default:
      console.log(`Unhandled event type: ${event.type}`);
  }
}
```

## Event Handler Implementations

```typescript
async function handleCheckoutCompleted(session: Stripe.Checkout.Session) {
  const userId = session.metadata?.userId;
  if (!userId) {
    console.error('No userId in checkout session metadata');
    return;
  }

  if (session.mode === 'subscription') {
    // Activate the subscription for the user
    await db.user.update({
      where: { id: userId },
      data: {
        stripeCustomerId: session.customer as string,
        subscriptionId: session.subscription as string,
        subscriptionStatus: 'active',
      },
    });
  } else if (session.mode === 'payment') {
    // Fulfill the one-time purchase
    await fulfillOrder(userId, session);
  }
}

async function handleInvoicePaid(invoice: Stripe.Invoice) {
  const customerId = invoice.customer as string;
  // Update billing records, send receipt, extend access
  await db.billing.create({
    data: {
      stripeCustomerId: customerId,
      stripeInvoiceId: invoice.id,
      amount: invoice.amount_paid,
      currency: invoice.currency,
      paidAt: new Date(invoice.status_transitions?.paid_at! * 1000),
    },
  });
}

async function handleInvoicePaymentFailed(invoice: Stripe.Invoice) {
  const customerId = invoice.customer as string;
  // Notify the customer, mark subscription as past_due
  await notifyPaymentFailed(customerId, invoice);
}

async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  // Sync subscription status to your database
  await db.user.update({
    where: { stripeCustomerId: subscription.customer as string },
    data: {
      subscriptionStatus: subscription.status,
      currentPeriodEnd: new Date(subscription.current_period_end * 1000),
      cancelAtPeriodEnd: subscription.cancel_at_period_end,
    },
  });
}

async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  // Revoke access when subscription is canceled
  await db.user.update({
    where: { stripeCustomerId: subscription.customer as string },
    data: {
      subscriptionStatus: 'canceled',
      subscriptionId: null,
    },
  });
}
```

## Logging Webhook Events

- **Log all webhook events** for debugging and audit purposes. Include the event type, event ID, and relevant object IDs.

```typescript
function logWebhookEvent(event: Stripe.Event) {
  const obj = event.data.object as any;
  console.log(JSON.stringify({
    level: 'info',
    source: 'stripe_webhook',
    eventId: event.id,
    eventType: event.type,
    objectId: obj.id,
    livemode: event.livemode,
    created: new Date(event.created * 1000).toISOString(),
    apiVersion: event.api_version,
  }));
}
```

## Retry Handling

- **Stripe retries webhook delivery** for up to 3 days with exponential backoff. Your endpoint should handle retries gracefully:
  - Return `200` for successfully processed events (including already-processed duplicates).
  - Return `400` for malformed requests or invalid signatures.
  - Return `500` only for unexpected server errors (Stripe will retry).
  - **Never return 200 for events you haven't processed** — let Stripe retry instead.

## Testing Webhooks Locally

- **Use the Stripe CLI** to forward webhooks to your local development server:

```bash
# Install the Stripe CLI and log in
stripe login

# Forward webhooks to your local server
stripe listen --forward-to localhost:3000/api/webhooks/stripe

# In another terminal, trigger test events
stripe trigger checkout.session.completed
stripe trigger invoice.paid
stripe trigger customer.subscription.updated
```

## Raw Body Requirement

- **Webhook signature verification requires the raw request body.** Make sure your web framework doesn't parse the body before it reaches the webhook handler.

```typescript
// Express — disable body parsing for the webhook route
app.post(
  '/api/webhooks/stripe',
  express.raw({ type: 'application/json' }),
  webhookHandler
);

// Next.js App Router — use req.text() for raw body
export async function POST(req: Request) {
  const body = await req.text();
  const sig = req.headers.get('stripe-signature')!;
  const event = stripe.webhooks.constructEvent(body, sig, webhookSecret);
  // ...
}

// Next.js Pages Router — disable body parsing
export const config = { api: { bodyParser: false } };
```
