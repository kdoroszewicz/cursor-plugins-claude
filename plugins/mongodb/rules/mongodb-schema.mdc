---
description: Best practices for MongoDB schema design, document modeling, embedding vs referencing, validation, and data types
globs:
  - "**/*.ts"
  - "**/*.js"
  - "**/models/**"
  - "**/schemas/**"
alwaysApply: false
---

# MongoDB Schema Design Best Practices

## Design for Your Queries, Not Normalization

- MongoDB is **not** a relational database — do not blindly normalize data into separate collections.
- Identify your application's **read and write patterns** first, then design the schema to support them efficiently.
- Optimize for the most frequent queries — denormalization is expected and encouraged when it reduces query complexity.
- Ask: "What questions will my application ask of this data?" and model accordingly.

## Embedding vs Referencing

### Embed When

- The related data is **always read together** with the parent document (e.g., shipping address on an order).
- The related data has a **bounded, small cardinality** (e.g., a user's phone numbers, an order's line items).
- The related data **does not change independently** of the parent document.
- You want **atomic reads** — a single query returns all needed data.

```typescript
// GOOD: Embed address inside user — always read together
const userSchema = new Schema({
  name: String,
  email: { type: String, unique: true },
  addresses: [{
    label: { type: String, enum: ['home', 'work', 'other'] },
    street: String,
    city: String,
    state: String,
    zip: String,
    country: { type: String, default: 'US' },
  }],
});
```

### Reference When

- The related data is **large or unbounded** (e.g., blog comments, log entries).
- The related data is **frequently updated independently** of the parent.
- The related data **needs to be queried on its own** (e.g., finding all comments by a user).
- The related data is **shared across multiple parent documents** (e.g., categories, tags).

```typescript
// GOOD: Reference comments — unbounded, queried independently
const postSchema = new Schema({
  title: String,
  content: String,
  author: { type: Schema.Types.ObjectId, ref: 'User' },
});

const commentSchema = new Schema({
  post: { type: Schema.Types.ObjectId, ref: 'Post', index: true },
  author: { type: Schema.Types.ObjectId, ref: 'User', index: true },
  body: String,
  createdAt: { type: Date, default: Date.now },
});
```

### Hybrid Pattern (Subset Pattern)

- Embed a **subset** of the referenced data for fast reads; store the full data in a separate collection.
- Use this for data that is read frequently but changes rarely (e.g., embed the latest 5 reviews on a product, store all reviews in a reviews collection).

```typescript
// Hybrid: embed last 3 reviews for fast display, full reviews in separate collection
const productSchema = new Schema({
  name: String,
  price: Schema.Types.Decimal128,
  recentReviews: [{
    _id: Schema.Types.ObjectId,
    rating: Number,
    summary: String,
    author: String,
  }],
  reviewCount: { type: Number, default: 0 },
});
```

## Document Size

- MongoDB has a hard limit of **16 MB per document** — design schemas to stay well under this limit.
- Avoid patterns that allow arrays or embedded documents to grow without bound.
- Use the **Bucket Pattern** for time-series or high-volume data:

```typescript
// Bucket Pattern: group sensor readings by hour
const sensorBucketSchema = new Schema({
  sensorId: { type: String, index: true },
  startDate: Date,
  endDate: Date,
  readings: [{
    timestamp: Date,
    value: Number,
  }],
  count: Number,  // track count for efficient bucket rotation
});
```

## Use Proper Data Types

- Use **`ObjectId`** for references between documents — never store IDs as plain strings.
- Use **`Date`** for timestamps — never store dates as strings or Unix timestamps.
- Use **`Decimal128`** for currency and financial values — `Number` (IEEE 754 double) cannot represent all decimal values exactly.
- Use **`Boolean`** for true/false flags — never use `0`/`1` or `"true"`/`"false"` strings.
- Use **`Int32`** or **`Long`** for integer counters — avoid floating-point `Number` for values that should never be fractional.
- Use **`Buffer`** / **`BinData`** for binary data — never Base64-encode into strings.

```typescript
const orderSchema = new Schema({
  orderNumber: { type: String, unique: true },
  customer: { type: Schema.Types.ObjectId, ref: 'Customer', required: true },
  total: { type: Schema.Types.Decimal128, required: true },
  items: [{
    product: { type: Schema.Types.ObjectId, ref: 'Product' },
    quantity: { type: Number, min: 1 },
    unitPrice: Schema.Types.Decimal128,
  }],
  status: {
    type: String,
    enum: ['pending', 'confirmed', 'shipped', 'delivered', 'cancelled'],
    default: 'pending',
  },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now },
});
```

## Add Validation with JSON Schema

- Use MongoDB's **JSON Schema validation** or Mongoose validators to enforce data integrity at the database level.
- Define `required` fields, `enum` constraints, `min`/`max` values, and `pattern` regex.
- Validate at the schema level — do not rely solely on application code.

```typescript
// Mongoose validation
const userSchema = new Schema({
  email: {
    type: String,
    required: [true, 'Email is required'],
    unique: true,
    lowercase: true,
    trim: true,
    match: [/^\S+@\S+\.\S+$/, 'Please provide a valid email'],
  },
  age: {
    type: Number,
    min: [0, 'Age cannot be negative'],
    max: [150, 'Age seems unrealistic'],
  },
  role: {
    type: String,
    enum: {
      values: ['user', 'admin', 'moderator'],
      message: '{VALUE} is not a valid role',
    },
    default: 'user',
  },
});
```

```javascript
// Native driver: JSON Schema collection validation
db.createCollection('users', {
  validator: {
    $jsonSchema: {
      bsonType: 'object',
      required: ['email', 'name', 'role'],
      properties: {
        email: {
          bsonType: 'string',
          pattern: '^\\S+@\\S+\\.\\S+$',
          description: 'Must be a valid email address',
        },
        role: {
          bsonType: 'string',
          enum: ['user', 'admin', 'moderator'],
        },
        age: {
          bsonType: 'int',
          minimum: 0,
          maximum: 150,
        },
      },
    },
  },
  validationAction: 'error',
  validationLevel: 'strict',
});
```

## Use Discriminators for Polymorphism

- Use **discriminators** to store different document shapes in the same collection while sharing a common base schema.
- Prefer discriminators over separate collections when entities share most fields but differ in a few.

```typescript
const eventSchema = new Schema({
  timestamp: { type: Date, default: Date.now },
  user: { type: Schema.Types.ObjectId, ref: 'User' },
}, { discriminatorKey: 'kind' });

const Event = model('Event', eventSchema);

const ClickEvent = Event.discriminator('ClickEvent', new Schema({
  element: String,
  page: String,
  coordinates: { x: Number, y: Number },
}));

const PurchaseEvent = Event.discriminator('PurchaseEvent', new Schema({
  product: { type: Schema.Types.ObjectId, ref: 'Product' },
  amount: Schema.Types.Decimal128,
  currency: { type: String, default: 'USD' },
}));
```

## Version Your Schemas

- Add a **`schemaVersion`** field to documents to enable graceful migration of document shapes over time.
- Handle multiple schema versions in application code during rolling migrations.
- Never assume all documents in a collection have the same shape.

```typescript
const userSchema = new Schema({
  schemaVersion: { type: Number, default: 2 },
  name: String,       // v1: was 'firstName' + 'lastName'
  email: String,
  // ... other fields
});

// Migration middleware: upgrade v1 documents on read
userSchema.post('init', function (doc) {
  if (doc.schemaVersion === 1) {
    doc.name = `${doc.firstName} ${doc.lastName}`;
    doc.schemaVersion = 2;
    doc.save();
  }
});
```

## Plan for Sharding from the Start

- Choose your **shard key** early — it is **extremely difficult** to change after data is distributed.
- Select a shard key with **high cardinality**, **even distribution**, and **query isolation** (most queries include the shard key).
- Avoid monotonically increasing shard keys (`_id`, timestamps) as the sole shard key — they cause hot spots.
- Consider **hashed shard keys** for even distribution or **compound shard keys** for query targeting.

```javascript
// Hashed shard key for even distribution
sh.shardCollection('mydb.events', { userId: 'hashed' });

// Compound shard key for query targeting + distribution
sh.shardCollection('mydb.orders', { customerId: 1, createdAt: 1 });
```

## Field Naming Conventions

- Use **camelCase** for field names (e.g., `firstName`, `orderTotal`, `createdAt`).
- **Never** use `$` as a field name prefix — it conflicts with MongoDB operators.
- **Never** use `.` in field names — it conflicts with dot-notation path syntax.
- Keep field names **short but descriptive** — they are stored in every document and affect storage size.
- Use **consistent naming** across collections (e.g., always `createdAt`, not sometimes `created_at`).
- Always include `createdAt` and `updatedAt` timestamps on every document.

```typescript
// Mongoose: auto-manage timestamps
const schema = new Schema(
  { name: String, email: String },
  { timestamps: true }  // adds createdAt and updatedAt automatically
);
```

## General Schema Guidelines

- **Keep documents reasonably flat** — avoid deep nesting beyond 3-4 levels.
- **Use lean queries** when you don't need Mongoose document features:
  ```typescript
  const users = await User.find({ active: true }).lean();
  ```
- **Separate hot and cold data** — archive or move infrequently accessed data to keep working sets small.
- **Use TTL indexes** for data that should expire automatically:
  ```typescript
  sessionSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });
  ```
- **Use capped collections** for fixed-size logging or streaming scenarios:
  ```javascript
  db.createCollection('logs', { capped: true, size: 1048576, max: 5000 });
  ```
