---
description: AWS CDK best practices for infrastructure-as-code projects
globs:
  - "**/cdk/**"
  - "**/lib/**/*.ts"
  - "**/bin/**/*.ts"
  - "cdk.json"
  - "**/infra/**/*.ts"
alwaysApply: false
---

# AWS CDK Best Practices

## Use L2/L3 Constructs Over L1

- Prefer L2 (curated) and L3 (pattern) constructs over L1 (`Cfn*`) constructs whenever available.
- L2 constructs provide sensible defaults, helper methods, and grant-based IAM.
- L3 constructs (patterns) compose multiple resources for common architectures (e.g., `LambdaRestApi`).
- Only drop to L1 constructs when L2 does not expose a required CloudFormation property.

```typescript
// ✅ L2 construct — sensible defaults, grant helpers
import * as s3 from "aws-cdk-lib/aws-s3";

const bucket = new s3.Bucket(this, "DataBucket", {
  versioned: true,
  encryption: s3.BucketEncryption.S3_MANAGED,
  removalPolicy: cdk.RemovalPolicy.RETAIN,
});

// ✅ L3 construct — high-level pattern
import * as apigw from "aws-cdk-lib/aws-apigateway";
const api = new apigw.LambdaRestApi(this, "Api", { handler: fn });

// ❌ L1 construct — verbose, no helpers, no defaults
import * as s3 from "aws-cdk-lib/aws-s3";
const cfnBucket = new s3.CfnBucket(this, "DataBucket", { /* ... */ });
```

## Tag All Resources

- Tag all resources with at minimum: `Environment`, `Project`, `Owner`, and `ManagedBy: CDK`.
- Use `cdk.Tags.of(scope).add(key, value)` to apply tags at the stack or app level for inheritance.
- Use tag-based cost allocation and access-control policies.
- Add a `CostCenter` tag for finance tracking.

```typescript
cdk.Tags.of(app).add("ManagedBy", "CDK");
cdk.Tags.of(app).add("Project", "my-service");
cdk.Tags.of(app).add("Environment", props.environment);
cdk.Tags.of(app).add("Owner", "platform-team");
```

## Removal Policies

- Set `removalPolicy` explicitly on every stateful resource (databases, buckets, file systems, log groups).
- Use `RemovalPolicy.RETAIN` for production data stores to prevent accidental deletion.
- Use `RemovalPolicy.DESTROY` only in development or ephemeral stacks.
- Enable `autoDeleteObjects` on S3 buckets paired with `DESTROY` to avoid stack-delete failures.

```typescript
// Production — retain data on stack deletion
const prodTable = new dynamodb.Table(this, "Table", {
  removalPolicy: cdk.RemovalPolicy.RETAIN,
  pointInTimeRecovery: true,
  // ...
});

// Dev — destroy on stack deletion
const devBucket = new s3.Bucket(this, "DevBucket", {
  removalPolicy: cdk.RemovalPolicy.DESTROY,
  autoDeleteObjects: true,
});
```

## Parameterize with Context and Environment

- Use `cdk.json` context values or `-c` flags for environment-specific configuration.
- Access context values via `this.node.tryGetContext("key")`.
- Never hardcode account IDs, regions, or environment-specific values in construct code.
- Use typed configuration objects for each environment.

```typescript
const environment = this.node.tryGetContext("environment") ?? "dev";
const config = this.node.tryGetContext(environment);

// Use in stack
new MyStack(app, `MyService-${environment}`, {
  env: { account: config.account, region: config.region },
  environment,
});
```

## Follow Naming Conventions

- Use a consistent naming convention: `<Project>-<Environment>-<Component>Stack`.
- Set `stackName` explicitly to control CloudFormation stack names.
- Use PascalCase for construct IDs, kebab-case for physical resource names.
- Prefix resource names with the project and environment to avoid collisions.

```typescript
new ApiStack(app, "MyService-Prod-ApiStack", {
  stackName: "myservice-prod-api",
  env: { account: "123456789012", region: "us-east-1" },
});
```

## Use Stack Separation

- Keep stacks focused on a single domain: networking, data, compute, monitoring.
- Separate stateful resources (databases, buckets) from stateless resources (Lambda, API Gateway).
- Use cross-stack references sparingly; prefer passing values through construct props.
- Keep stacks under 500 resources to avoid CloudFormation limits and slow deployments.

```typescript
// Separate stacks by domain
const networkStack = new NetworkStack(app, "Network", { env });
const dataStack = new DataStack(app, "Data", { env, vpc: networkStack.vpc });
const computeStack = new ComputeStack(app, "Compute", {
  env,
  vpc: networkStack.vpc,
  table: dataStack.table,
});
```

## Enable Termination Protection for Production

- Enable termination protection on production stacks to prevent accidental deletion.
- Use `cdk.Stack` `terminationProtection` property.
- Only disable termination protection through an intentional change, never in CI/CD.

```typescript
new MyStack(app, "MyService-Prod", {
  terminationProtection: true, // Prevent accidental stack deletion
  env: { account: "123456789012", region: "us-east-1" },
});
```

## Construct Library Patterns

- Organize infrastructure into reusable construct libraries with well-defined interfaces.
- Keep constructs single-purpose; compose larger architectures from smaller constructs.
- Export construct props interfaces for consumers to configure behavior.
- Document every construct with JSDoc comments.

```typescript
export interface ApiConstructProps {
  readonly tableName: string;
  readonly stageName?: string;
}

export class ApiConstruct extends Construct {
  public readonly api: apigateway.RestApi;

  constructor(scope: Construct, id: string, props: ApiConstructProps) {
    super(scope, id);
    // ...
  }
}
```

## CDK Aspects for Compliance

- Use CDK Aspects to enforce organizational policies across all constructs in a scope.
- Common checks: encryption enabled, public access blocked, logging enabled.
- Run aspects at synth time to catch violations before deployment.

```typescript
import { Aspects, IAspect } from "aws-cdk-lib";

class BucketEncryptionChecker implements IAspect {
  public visit(node: IConstruct): void {
    if (node instanceof s3.Bucket) {
      if (!node.encryptionKey) {
        Annotations.of(node).addWarning("Bucket should use KMS encryption");
      }
    }
  }
}

Aspects.of(stack).add(new BucketEncryptionChecker());
```

## Use CDK Nag for Compliance

- Integrate `cdk-nag` into your CDK app to enforce AWS security best practices at synth time.
- Apply rule packs such as `AwsSolutionsChecks`, `NIST80053R5Checks`, or `HIPAASecurityChecks`.
- Suppress individual rules only with documented justification.
- Run cdk-nag in CI/CD to block non-compliant deployments.

```typescript
import { AwsSolutionsChecks, NagSuppressions } from "cdk-nag";

Aspects.of(app).add(new AwsSolutionsChecks({ verbose: true }));

// Suppress with justification
NagSuppressions.addResourceSuppressions(myBucket, [
  { id: "AwsSolutions-S1", reason: "Access logging handled by centralized logging account" },
]);
```

## CDK Testing

- Write snapshot tests to detect unintended infrastructure drift.
- Write fine-grained assertion tests for critical resources using `aws-cdk-lib/assertions`.
- Test construct behavior, not just template output.
- Run tests in CI/CD to catch regressions before deployment.

```typescript
import { Template } from "aws-cdk-lib/assertions";

test("creates DynamoDB table with PAY_PER_REQUEST billing", () => {
  const app = new cdk.App();
  const stack = new MyStack(app, "TestStack");
  const template = Template.fromStack(stack);

  template.hasResourceProperties("AWS::DynamoDB::Table", {
    BillingMode: "PAY_PER_REQUEST",
  });
});
```
