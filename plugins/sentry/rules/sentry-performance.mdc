---
description: Best practices for Sentry performance monitoring — custom transactions, spans, sampling, profiling, and web vitals tracking.
globs: **/*.ts, **/*.tsx, **/*.js
---

# Sentry Performance Monitoring Best Practices

## Custom Transactions for Business Operations

- Create custom transactions around important business flows so they appear as discrete units in the Performance dashboard:

```ts
const transaction = Sentry.startTransaction({
  op: "checkout",
  name: "POST /api/checkout",
  data: { cartItems: cart.items.length },
});

Sentry.getCurrentHub().configureScope((scope) => {
  scope.setSpan(transaction);
});

try {
  await validateCart(cart);
  await chargePayment(cart);
  await createOrder(cart);
  transaction.setStatus("ok");
} catch (error) {
  transaction.setStatus("internal_error");
  Sentry.captureException(error);
  throw error;
} finally {
  transaction.finish();
}
```

> **Note:** In SDK v8+ the recommended API uses `Sentry.startSpan` / `Sentry.startInactiveSpan` which automatically manage the scope. Prefer the newer API when available:

```ts
await Sentry.startSpan(
  { op: "checkout", name: "POST /api/checkout" },
  async (span) => {
    await validateCart(cart);
    await chargePayment(cart);
    await createOrder(cart);
  }
);
```

## Adding Child Spans for Detailed Timing

- Break transactions into child spans to identify exactly where time is spent:

```ts
await Sentry.startSpan(
  { op: "checkout", name: "POST /api/checkout" },
  async () => {
    await Sentry.startSpan(
      { op: "db.query", name: "validate-cart" },
      async () => {
        await validateCart(cart);
      }
    );

    await Sentry.startSpan(
      { op: "http.client", name: "charge-payment-gateway" },
      async () => {
        await chargePayment(cart);
      }
    );

    await Sentry.startSpan(
      { op: "db.insert", name: "create-order-record" },
      async () => {
        await createOrder(cart);
      }
    );
  }
);
```

- Use descriptive `op` values that follow Sentry conventions: `db.query`, `http.client`, `http.server`, `grpc.client`, `queue.process`, `cache.get`, `serialize`, `template.render`, etc.

## Meaningful Transaction Names

- Use a consistent naming convention for transactions so they aggregate correctly in the Performance dashboard:
  - **HTTP endpoints**: `GET /api/users/:id` (parameterized, not `/api/users/123`).
  - **Background jobs**: `job.send-welcome-email`, `job.generate-report`.
  - **Frontend pages**: `pageload /dashboard`, `navigation /settings`.
- Avoid high-cardinality transaction names (e.g., embedding UUIDs or query strings) — they fragment your data and make it hard to spot trends.

## Traces Sample Rate Configuration

- **Never** set `tracesSampleRate: 1.0` in production unless traffic is extremely low. Sampling 100 % of traces at scale will:
  - Exhaust your Sentry quota rapidly.
  - Add unnecessary overhead to every request.
- Recommended production ranges:
  - **Low traffic** (< 10 k requests/day): `0.5`–`1.0`
  - **Medium traffic** (10 k–1 M requests/day): `0.1`–`0.3`
  - **High traffic** (> 1 M requests/day): `0.01`–`0.1`
- Use `tracesSampler` for dynamic, context-aware sampling:

```ts
Sentry.init({
  tracesSampler: (ctx) => {
    // Always trace critical paths
    if (ctx.name?.startsWith("POST /api/payment")) return 1.0;
    // Drop noisy health checks
    if (ctx.name?.includes("/healthz")) return 0;
    // Default
    return 0.2;
  },
});
```

## Profiling Slow Endpoints

- Enable Sentry Profiling to capture CPU flame graphs alongside traces:

```ts
import * as Sentry from "@sentry/node";
import { nodeProfilingIntegration } from "@sentry/profiling-node";

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  integrations: [nodeProfilingIntegration()],
  tracesSampleRate: 0.2,
  profilesSampleRate: 0.1, // profile 10 % of sampled transactions
});
```

- Profiling is most valuable for endpoints with high p95/p99 latency — focus sampling budget there using `profilesSampler`.
- Use the Profiling flamechart in Sentry to identify hot functions, excessive allocations, or synchronous bottlenecks.

## Tracking Web Vitals

- The Sentry Browser SDK automatically captures Core Web Vitals (LCP, FID/INP, CLS) when `BrowserTracing` integration is enabled:

```ts
import * as Sentry from "@sentry/react";

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  integrations: [Sentry.browserTracingIntegration()],
  tracesSampleRate: 0.3,
});
```

- Monitor Web Vitals in the Sentry Performance → Web Vitals dashboard to spot regressions per release.
- Add custom web-vital measurements for metrics Sentry does not capture automatically:

```ts
Sentry.startSpan({ name: "pageload /dashboard", op: "pageload" }, (span) => {
  // Custom measurement
  span.setAttribute("custom.time_to_interactive", ttiMs);
});
```

## Best Practices Summary

| Practice | Rationale |
|---|---|
| Use parameterized transaction names | Prevents cardinality explosion and enables aggregation |
| Add child spans for I/O calls | Pinpoints latency sources within a transaction |
| Set `tracesSampleRate` < 1.0 in prod | Avoids quota exhaustion and runtime overhead |
| Enable profiling for slow paths | Identifies CPU-level bottlenecks that spans alone cannot reveal |
| Monitor Web Vitals per release | Catches frontend perf regressions before users report them |
| Use `tracesSampler` over static rate | Allows per-route control and keeps critical paths fully sampled |
