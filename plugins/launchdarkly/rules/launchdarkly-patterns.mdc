---
description: Feature flag design patterns and strategies for LaunchDarkly
globs:
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.js"
alwaysApply: false
---

# LaunchDarkly Feature Flag Patterns

## Kill Switches for Critical Features

- Wrap every critical or risky feature behind a boolean kill switch flag.
- Kill switches should default to **on** (the feature works) and can be turned **off** instantly to disable.
- Name kill switches clearly: `payments-kill-switch`, `search-circuit-breaker`.
- Kill switches are permanent flags — they stay in the codebase and dashboard indefinitely.
- Document the blast radius and rollback procedure for each kill switch.

```typescript
// ✅ Correct — kill switch pattern (default true = feature enabled)
const paymentsEnabled = await client.boolVariation("payments-kill-switch", context, true);

if (!paymentsEnabled) {
  return res.status(503).json({
    error: "Payment processing is temporarily unavailable",
    retryAfter: 300,
  });
}

// Proceed with payment processing
await processPayment(order);
```

## Progressive Rollouts (Percentage-Based)

- Use percentage-based rollouts to gradually expose a feature to increasing traffic.
- Start at 1–5%, monitor error rates and performance, then increase incrementally.
- Use LaunchDarkly's percentage rollout targeting (not custom random logic).
- Define a rollout plan before starting: 5% → 10% → 25% → 50% → 100%.
- Always roll out by a sticky attribute (user key) so users get a consistent experience.

```typescript
// The percentage rollout is configured in the LaunchDarkly dashboard.
// In code, simply evaluate the flag — LaunchDarkly handles bucketing.
const useNewCheckout = await client.boolVariation("checkout-v2-rollout", context, false);

if (useNewCheckout) {
  return renderNewCheckout(cart);
} else {
  return renderLegacyCheckout(cart);
}
```

### Recommended Rollout Plan

| Phase | Percentage | Duration | Monitoring |
|-------|-----------|----------|------------|
| Canary | 1–2% | 1 hour | Error rate, latency p99, support tickets |
| Early adopters | 5–10% | 24 hours | Conversion rate, error rate, user feedback |
| Partial | 25% | 48 hours | Business KPIs, performance dashboards |
| Majority | 50% | 48 hours | Full metric suite |
| General availability | 100% | Permanent | Standard monitoring |

## Targeting Rules for Beta Users

- Use targeting rules to enable features for specific user segments before broader rollout.
- Create segments in LaunchDarkly for internal users, beta testers, enterprise customers, etc.
- Use context attributes for targeting: `plan`, `company`, `email domain`, `role`.
- Layer targeting with percentage rollouts: "100% for beta segment, 10% for everyone else."

```typescript
// Context with targeting attributes
const context: LaunchDarkly.LDContext = {
  kind: "multi",
  user: {
    key: user.id,
    email: user.email,
    custom: {
      plan: user.plan,           // "free" | "pro" | "enterprise"
      role: user.role,           // "admin" | "member"
      betaTester: user.isBeta,   // true | false
    },
  },
  organization: {
    key: org.id,
    name: org.name,
    custom: {
      plan: org.plan,
      industry: org.industry,
    },
  },
};

// LaunchDarkly targeting rules (configured in dashboard):
// Rule 1: If user.betaTester = true → serve true
// Rule 2: If organization.plan = "enterprise" → serve true
// Rule 3: Default → percentage rollout 10%
const showAdvancedAnalytics = await client.boolVariation(
  "analytics-advanced-dashboard",
  context,
  false
);
```

## Flag-Driven Trunk-Based Development

- Use feature flags to merge incomplete features into the main branch safely.
- Wrap work-in-progress code behind a flag that is **off** in production.
- This eliminates long-lived feature branches, reduces merge conflicts, and enables CI/CD.
- Mark these flags as **temporary** — they must be removed after the feature is complete and fully rolled out.

```typescript
// ✅ Correct — trunk-based development with feature flag
const enableNewSearchEngine = await client.boolVariation(
  "search-new-engine",
  context,
  false // off by default — safe to merge to main
);

export async function search(query: string): Promise<SearchResults> {
  if (enableNewSearchEngine) {
    return newElasticsearchEngine.search(query);
  }
  return legacySearchEngine.search(query);
}
```

## Avoid Complex Logic in Flag Evaluations

- Keep flag evaluation code simple — a single `if/else` or switch statement.
- Do not embed business logic, computations, or side effects inside flag branches.
- Extract complex behavior into separate functions and use the flag to select which function to call.

```typescript
// ❌ Wrong — complex logic mixed with flag evaluation
const useNewPricing = await client.boolVariation("pricing-v2", context, false);
if (useNewPricing) {
  const discount = user.plan === "enterprise" ? 0.2 : user.tenure > 12 ? 0.1 : 0;
  const tax = calculateTax(order.total, user.country);
  order.total = order.total * (1 - discount) + tax;
  // ... 50 more lines
}

// ✅ Correct — flag selects a strategy, logic lives in dedicated functions
const useNewPricing = await client.boolVariation("pricing-v2", context, false);
const pricingStrategy = useNewPricing ? newPricingStrategy : legacyPricingStrategy;
order.total = await pricingStrategy.calculate(order, user);
```

## Use Flag Prerequisites

- Use LaunchDarkly's prerequisite feature to model flag dependencies explicitly.
- A prerequisite ensures flag B is only evaluated if flag A is serving a specific variation.
- This replaces ad-hoc nested flag checks in code.
- Configure prerequisites in the LaunchDarkly dashboard, not in application code.

```
Dashboard configuration:
  Flag: "checkout-express-pay"
  Prerequisite: "checkout-v2" must serve "true"

  → express-pay is automatically OFF unless checkout-v2 is ON.
```

```typescript
// ✅ Correct — prerequisites configured in dashboard; code is simple
const expressPayEnabled = await client.boolVariation("checkout-express-pay", context, false);
if (expressPayEnabled) {
  renderExpressPayButton();
}
// No need to check "checkout-v2" in code — the prerequisite handles it.
```

## Temporary vs. Permanent Flags

- **Temporary flags** gate in-progress features and rollouts. Remove them after full rollout.
- **Permanent flags** are operational controls: kill switches, entitlements, configuration.
- Mark every flag as temporary or permanent when creating it in the dashboard.
- Set up alerts or scheduled reviews for temporary flags older than 30 days.

| Type | Examples | Lifecycle |
|------|----------|-----------|
| Temporary | `checkout-v2-rollout`, `search-new-algorithm` | Create → rollout → remove |
| Permanent | `payments-kill-switch`, `max-upload-size-mb` | Create → maintain indefinitely |

```typescript
// Temporary flag — remove after full rollout
const showNewOnboarding = await client.boolVariation("onboarding-v2", context, false);

// Permanent flag — operational control, stays forever
const maintenanceMode = await client.boolVariation("maintenance-mode", context, false);
```

## Flag-Based A/B Testing and Experimentation

- Use LaunchDarkly's experimentation features to run A/B tests with statistical rigor.
- Define a hypothesis, success metric, and sample size before starting an experiment.
- Use multivariate flags for experiments with more than two variants.
- Track conversion events using `client.track()` to feed the experimentation engine.
- Let the experiment run to statistical significance — do not peek and make decisions early.

```typescript
// Multivariate experiment — three checkout button styles
const checkoutButtonVariant = await client.stringVariation(
  "checkout-button-experiment",
  context,
  "control" // "control" | "variant-a" | "variant-b"
);

// Render the appropriate variant
switch (checkoutButtonVariant) {
  case "variant-a":
    renderGreenButton();
    break;
  case "variant-b":
    renderAnimatedButton();
    break;
  default:
    renderDefaultButton();
}

// Track the conversion event for the experiment
function onCheckoutComplete(orderId: string, revenue: number): void {
  client.track("checkout-completed", context, { orderId }, revenue);
}
```

## Handle Flag Evaluation Events for Analytics

- Use `client.track()` to send custom events tied to flag evaluations.
- Track meaningful business events: purchases, sign-ups, page views, errors.
- Include metric values (numeric) for revenue, duration, or count-based metrics.
- Use `client.variationDetail()` to get the evaluation reason alongside the value for debugging.

```typescript
// Track a business event with a metric value
client.track("purchase-completed", context, { orderId: "abc-123" }, 49.99);

// Track a count-based event
client.track("search-performed", context, { query });

// Get detailed evaluation information for debugging
const detail = await client.variationDetail("checkout-v2", context, false);
console.log({
  value: detail.value,
  variationIndex: detail.variationIndex,
  reason: detail.reason, // e.g., { kind: "RULE_MATCH", ruleIndex: 0 }
});
```

## Feature Flag Lifecycle Management

- Every flag should follow a defined lifecycle: **plan → create → test → rollout → clean up**.
- Document the purpose, owner, and expected removal date for every temporary flag.
- Use LaunchDarkly tags to categorize flags by team, project, or lifecycle stage.
- Automate stale flag detection using the LaunchDarkly API or code references.

### Lifecycle Stages

```
Plan → Create → Dev/Test → Canary → Rollout → Monitor → GA → Remove (temporary)
                                                             → Maintain (permanent)
```

## Configuration Flags

- Use feature flags for runtime configuration: rate limits, timeouts, UI copy, theme colors.
- These are typically permanent, multivariate flags (string, number, or JSON).
- Changing configuration via flags is instant — no redeployment needed.

```typescript
// Runtime configuration via flags
const rateLimitPerMinute = await client.numberVariation("api-rate-limit", context, 100);
const supportEmail = await client.stringVariation("support-email", context, "help@example.com");
const featureConfig = await client.jsonVariation("dashboard-config", context, {
  maxWidgets: 10,
  refreshInterval: 30,
  theme: "light",
});
```

## Server-Side vs. Client-Side Flags

- Use server-side SDKs for backend services — they receive the full flag ruleset.
- Use client-side SDKs for frontend apps — they only receive evaluated flag values for the current context.
- Never expose your server-side SDK key in client-side code.
- Use the client-side ID (safe to expose) in browser and mobile applications.
- Keep sensitive flags server-side only — mark them as unavailable to client-side SDKs in the dashboard.

```typescript
// ✅ Server-side — uses SDK key (secret, backend only)
import * as LaunchDarkly from "@launchdarkly/node-server-sdk";
const serverClient = LaunchDarkly.init(process.env.LD_SDK_KEY!);

// ✅ Client-side — uses client-side ID (safe to expose)
import { LDProvider } from "launchdarkly-react-client-sdk";
<LDProvider clientSideID="your-client-side-id">...</LDProvider>
```
