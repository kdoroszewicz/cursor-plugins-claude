---
description: Firestore best practices for data modeling, queries, and performance
globs: ["**/*.ts", "**/*.tsx", "**/*.js"]
---

# Firestore Best Practices

## Data Modeling

- Design data models for query patterns, not for normalization — denormalize when needed to avoid expensive joins.
- Use subcollections for 1:N relationships where the child data is queried independently.
- Keep documents small; Firestore has a 1 MiB document size limit. Store large blobs in Cloud Storage instead.
- Prefer flat data structures; avoid deeply nested maps that complicate partial updates.
- Use collection group queries (`collectionGroup()`) for querying across subcollections with the same name.

```typescript
// ✅ Correct — subcollection for 1:N relationship
const messagesRef = collection(db, "chats", chatId, "messages");

// ✅ Correct — collection group query across all "messages" subcollections
const allMessages = await getDocs(
  query(collectionGroup(db, "messages"), where("senderId", "==", userId))
);
```

## Batch Writes and Transactions

- Use batch writes (`writeBatch()`) for multiple independent document updates (up to 500 operations per batch).
- Use transactions (`runTransaction()`) for atomic read-then-write operations where consistency is required.
- Never perform side effects (API calls, logging) inside transaction handlers — they may be retried.

```typescript
// ✅ Correct — batch write for multiple independent updates
const batch = writeBatch(db);
batch.set(doc(db, "users", uid), userData);
batch.update(doc(db, "counters", "users"), { count: increment(1) });
await batch.commit();

// ✅ Correct — transaction for atomic read-then-write
await runTransaction(db, async (transaction) => {
  const docSnap = await transaction.get(docRef);
  const newCount = (docSnap.data()?.count ?? 0) + 1;
  transaction.update(docRef, { count: newCount });
});
```

## Indexes and Queries

- Use composite indexes for queries that filter or order on multiple fields. Firestore will prompt you with an index creation link in error messages.
- Paginate large result sets with `limit()` and `startAfter()` using document snapshots or field values.
- Avoid using `!=` and `not-in` operators on large collections — they are less efficient.
- Use `orderBy()` in the same direction as your inequality filter field.

```typescript
// ✅ Correct — paginated query
const firstPage = query(
  collection(db, "products"),
  orderBy("createdAt", "desc"),
  limit(25)
);
const snapshot = await getDocs(firstPage);
const lastDoc = snapshot.docs[snapshot.docs.length - 1];

const nextPage = query(
  collection(db, "products"),
  orderBy("createdAt", "desc"),
  startAfter(lastDoc),
  limit(25)
);
```

## Timestamps and Server Values

- Always use `serverTimestamp()` for `createdAt` and `updatedAt` fields instead of `new Date()` — this ensures consistency across clients regardless of clock skew.
- Use `increment()` for atomic counter updates instead of read-then-write patterns.

```typescript
import { serverTimestamp, increment } from "firebase/firestore";

await setDoc(doc(db, "posts", postId), {
  title: "Hello World",
  createdAt: serverTimestamp(),
  updatedAt: serverTimestamp(),
  viewCount: 0,
});

// Atomic increment
await updateDoc(doc(db, "posts", postId), {
  viewCount: increment(1),
  updatedAt: serverTimestamp(),
});
```

## Type Safety with Converters

- Use Firestore data converters (`withConverter()`) to enforce TypeScript types on reads and writes.
- Define converter objects that implement `toFirestore()` and `fromFirestore()` methods.

```typescript
interface Post {
  title: string;
  content: string;
  createdAt: Timestamp;
}

const postConverter: FirestoreDataConverter<Post> = {
  toFirestore(post: Post): DocumentData {
    return { title: post.title, content: post.content, createdAt: post.createdAt };
  },
  fromFirestore(snapshot: QueryDocumentSnapshot): Post {
    const data = snapshot.data();
    return { title: data.title, content: data.content, createdAt: data.createdAt };
  },
};

const postRef = doc(db, "posts", postId).withConverter(postConverter);
const postSnap = await getDoc(postRef);
const post: Post | undefined = postSnap.data(); // Typed!
```

## Offline Persistence

- Enable offline persistence for web apps with `enableIndexedDbPersistence()` (or `enableMultiTabIndexedDbPersistence()` for multi-tab support).
- Handle the `FirestoreError` with code `failed-precondition` (multiple tabs) and `unimplemented` (browser lacks support).
- Use `onSnapshot()` listeners for real-time updates that work seamlessly offline.
- Be aware that offline writes are queued and applied when the client reconnects.

```typescript
import { enableIndexedDbPersistence } from "firebase/firestore";

try {
  await enableIndexedDbPersistence(db);
} catch (err: any) {
  if (err.code === "failed-precondition") {
    console.warn("Persistence requires single-tab access");
  } else if (err.code === "unimplemented") {
    console.warn("Browser does not support persistence");
  }
}
```

## Security Rules

- Never leave Firestore security rules in test mode (`allow read, write: if true`) in production.
- Always validate data types, required fields, and field value ranges in security rules.
- See the companion rule file `firebase-security-rules.mdc` for comprehensive security rule patterns.

## Cost Optimization

- Minimize document reads by caching and using `onSnapshot()` listeners (which count as one read per document change, not per listener attachment).
- Use `select()` field masks in Admin SDK queries to retrieve only the fields you need.
- Avoid full-collection reads; always scope queries with `where()` clauses.
- Use the Firestore emulator during development to avoid incurring billing costs.
