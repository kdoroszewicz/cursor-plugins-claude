---
description: Firebase security rules best practices for Firestore and Cloud Storage
globs: ["firestore.rules", "storage.rules", "**/*.rules"]
---

# Firebase Security Rules

## Authentication

- Always authenticate users before allowing reads or writes. Never use `allow read, write: if true` in production.
- Use `request.auth != null` as the baseline condition for all rules.
- Check `request.auth.uid` to scope access to the document owner.

```rules
// ✅ Correct — only authenticated users can read, only owners can write
match /users/{userId} {
  allow read: if request.auth != null;
  allow write: if request.auth.uid == userId;
}
```

## Data Validation

- Validate incoming data types, required fields, and value ranges in write rules.
- Use `request.resource.data` to inspect the incoming document state.
- Use `resource.data` to inspect the existing document state (for updates).
- Ensure string lengths, number ranges, and enum values are within expected bounds.

```rules
match /posts/{postId} {
  allow create: if request.auth != null
    && request.resource.data.title is string
    && request.resource.data.title.size() > 0
    && request.resource.data.title.size() <= 200
    && request.resource.data.content is string
    && request.resource.data.content.size() <= 50000
    && request.resource.data.createdAt == request.time;
}
```

## Custom Claims for Role-Based Access

- Use Firebase Auth custom claims to implement role-based access control (RBAC).
- Set custom claims via the Admin SDK (Cloud Functions), never from the client.
- Access claims in rules via `request.auth.token`.

```rules
// ✅ Correct — admin-only access via custom claims
match /admin/{document=**} {
  allow read, write: if request.auth.token.admin == true;
}

// ✅ Correct — role-based access
match /organizations/{orgId} {
  allow read: if request.auth.token.orgId == orgId;
  allow write: if request.auth.token.orgId == orgId
    && request.auth.token.role in ["admin", "editor"];
}
```

## Document Size Limits

- Validate document size constraints to prevent abuse.
- Limit the number of fields and array lengths in incoming documents.
- Use `request.resource.data.keys().size()` to check field count.

```rules
match /comments/{commentId} {
  allow create: if request.auth != null
    && request.resource.data.keys().size() <= 5
    && request.resource.data.text.size() <= 5000;
}
```

## Reusable Helper Functions

- Extract common validation logic into helper functions to keep rules DRY.
- Define functions at the top of your rules file or within `match` blocks.

```rules
rules_version = '2';
service cloud.firestore {
  // Helper: check if the user is authenticated
  function isAuthenticated() {
    return request.auth != null;
  }

  // Helper: check if the user owns the document
  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  // Helper: check if the user has a specific role
  function hasRole(role) {
    return request.auth.token.role == role;
  }

  // Helper: validate that a field is a non-empty string within a max length
  function isValidString(field, maxLen) {
    return field is string && field.size() > 0 && field.size() <= maxLen;
  }

  match /databases/{database}/documents {
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow write: if isOwner(userId);
    }

    match /posts/{postId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated()
        && isValidString(request.resource.data.title, 200)
        && isValidString(request.resource.data.content, 50000);
      allow update: if isOwner(resource.data.authorId);
      allow delete: if isOwner(resource.data.authorId) || hasRole("admin");
    }
  }
}
```

## Never Allow Unrestricted Access

- Never deploy rules that grant unrestricted reads or writes.
- Use granular `read` sub-rules (`get`, `list`) and `write` sub-rules (`create`, `update`, `delete`) for fine-grained control.

```rules
match /products/{productId} {
  // ✅ Fine-grained — anyone can view, only admins can list all
  allow get: if true;
  allow list: if request.auth.token.admin == true;

  // ✅ Fine-grained — separate create, update, delete
  allow create: if hasRole("editor");
  allow update: if hasRole("editor");
  allow delete: if hasRole("admin");
}
```

## Cloud Storage Security Rules

- Apply the same principles to Cloud Storage rules: authenticate, validate, and restrict.
- Validate file size, content type, and path structure.

```rules
rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    match /users/{userId}/avatar.{ext} {
      allow read: if request.auth != null;
      allow write: if request.auth.uid == userId
        && request.resource.size < 5 * 1024 * 1024  // 5 MB limit
        && request.resource.contentType.matches('image/.*');
    }

    match /public/{allPaths=**} {
      allow read: if true;
      allow write: if request.auth.token.admin == true;
    }
  }
}
```

## Testing Rules with the Emulator

- Always test security rules locally using the Firebase Emulator Suite before deploying.
- Use `@firebase/rules-unit-testing` to write automated rule tests.
- Test both allowed and denied scenarios for every rule.

```typescript
import { initializeTestEnvironment, assertSucceeds, assertFails } from "@firebase/rules-unit-testing";

const testEnv = await initializeTestEnvironment({
  projectId: "my-project",
  firestore: { rules: fs.readFileSync("firestore.rules", "utf8") },
});

// Test authenticated user can read their own document
const authedDb = testEnv.authenticatedContext("user123").firestore();
await assertSucceeds(getDoc(doc(authedDb, "users", "user123")));

// Test unauthenticated user cannot read
const unauthedDb = testEnv.unauthenticatedContext().firestore();
await assertFails(getDoc(doc(unauthedDb, "users", "user123")));

await testEnv.cleanup();
```
