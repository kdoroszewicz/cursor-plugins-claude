---
description: Best practices for using Prisma Client queries in TypeScript and JavaScript applications
globs:
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.js"
alwaysApply: false
---

# Prisma Query Best Practices

## Singleton Pattern

- **Always** use a singleton pattern for `PrismaClient` to avoid exhausting database connections:
  ```typescript
  // lib/prisma.ts
  import { PrismaClient } from '@prisma/client';

  const globalForPrisma = globalThis as unknown as { prisma: PrismaClient };

  export const prisma = globalForPrisma.prisma ?? new PrismaClient();

  if (process.env.NODE_ENV !== 'production') {
    globalForPrisma.prisma = prisma;
  }
  ```
- In serverless environments (AWS Lambda, Vercel), configure the connection pool size:
  ```typescript
  const prisma = new PrismaClient({
    datasources: {
      db: {
        url: `${process.env.DATABASE_URL}?connection_limit=1`,
      },
    },
  });
  ```

## Select and Include

- Use `select` to fetch only the fields you need — avoid over-fetching:
  ```typescript
  const user = await prisma.user.findUnique({
    where: { id },
    select: { id: true, name: true, email: true },
  });
  ```
- Use `include` when you need related data, but be mindful of the depth:
  ```typescript
  const post = await prisma.post.findUnique({
    where: { id },
    include: { author: true, comments: { take: 10 } },
  });
  ```
- Never use both `select` and `include` at the same level — they are mutually exclusive.

## Avoiding N+1 Queries

- **Never** fetch related data inside loops — use `include` or `select` to eager-load:
  ```typescript
  // BAD: N+1 — 1 query for users + N queries for posts
  const users = await prisma.user.findMany();
  for (const user of users) {
    const posts = await prisma.post.findMany({ where: { authorId: user.id } });
  }

  // GOOD: Single query with include
  const users = await prisma.user.findMany({
    include: { posts: true },
  });
  ```
- Watch for `Promise.all` wrapping individual queries that could be a single `include`.
- For GraphQL resolvers, use DataLoader patterns or Prisma's `relationLoadStrategy: 'join'`.

## Transactions

- Use **interactive transactions** for multi-step operations that must be atomic:
  ```typescript
  const result = await prisma.$transaction(async (tx) => {
    const user = await tx.user.create({ data: { name: 'Alice' } });
    const account = await tx.account.create({
      data: { userId: user.id, balance: 0 },
    });
    return { user, account };
  });
  ```
- Use **batch transactions** for independent writes:
  ```typescript
  await prisma.$transaction([
    prisma.post.create({ data: postData }),
    prisma.log.create({ data: logData }),
  ]);
  ```
- Set appropriate `timeout` and `maxWait` for long-running transactions:
  ```typescript
  await prisma.$transaction(
    async (tx) => { /* ... */ },
    { maxWait: 5000, timeout: 10000 }
  );
  ```

## Error Handling

- Handle `PrismaClientKnownRequestError` with specific error codes:
  ```typescript
  import { Prisma } from '@prisma/client';

  try {
    await prisma.user.create({ data });
  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === 'P2002') {
        // Unique constraint violation
        throw new ConflictError('A user with this email already exists');
      }
      if (error.code === 'P2025') {
        // Record not found
        throw new NotFoundError('User not found');
      }
      if (error.code === 'P2003') {
        // Foreign key constraint failed
        throw new BadRequestError('Referenced record does not exist');
      }
      if (error.code === 'P2014') {
        // Required relation violation
        throw new BadRequestError('Required relation is missing');
      }
    }
    throw error;
  }
  ```
- Common error codes:
  - `P2002` — Unique constraint failed
  - `P2025` — Record not found
  - `P2003` — Foreign key constraint failed
  - `P2014` — Required relation violation
  - `P2021` — Table does not exist
  - `P2022` — Column does not exist

## Query Patterns

- Use `findUniqueOrThrow` or `findFirstOrThrow` when a missing record is an error:
  ```typescript
  const user = await prisma.user.findUniqueOrThrow({
    where: { id },
  });
  ```
- **NEVER** use `queryRawUnsafe` — it is vulnerable to SQL injection. Always use parameterized raw queries:
  ```typescript
  // GOOD: Parameterized — safe from SQL injection
  const result = await prisma.$queryRaw`
    SELECT * FROM "User" WHERE email = ${email}
  `;

  // BAD: NEVER DO THIS — SQL injection risk
  // const result = await prisma.$queryRawUnsafe(`SELECT * FROM "User" WHERE email = '${email}'`);
  ```

## Type-Safe Queries with Prisma.validator

- Use `Prisma.validator` to create reusable, type-safe query fragments:
  ```typescript
  import { Prisma } from '@prisma/client';

  // Define a reusable select object
  const userWithPosts = Prisma.validator<Prisma.UserDefaultArgs>()({
    include: { posts: true },
  });

  // Use it in queries
  const user = await prisma.user.findUnique({
    where: { id },
    ...userWithPosts,
  });

  // Define reusable where conditions
  const activeUserFilter = Prisma.validator<Prisma.UserWhereInput>()({
    isActive: true,
    deletedAt: null,
  });

  const activeUsers = await prisma.user.findMany({
    where: activeUserFilter,
  });
  ```
- Extract query return types with `Prisma.UserGetPayload`:
  ```typescript
  type UserWithPosts = Prisma.UserGetPayload<typeof userWithPosts>;
  ```

## Cursor-Based Pagination

- Use **cursor-based pagination** for large datasets:
  ```typescript
  const page = await prisma.post.findMany({
    take: 20,
    skip: 1,
    cursor: { id: lastPostId },
    orderBy: { createdAt: 'desc' },
  });
  ```
- Offset-based pagination (`skip`/`take` without cursor) is acceptable for small datasets but degrades with large offsets.

## Batch Operations

- Use `createMany` for inserting multiple records efficiently:
  ```typescript
  await prisma.user.createMany({
    data: users,
    skipDuplicates: true,
  });
  ```
- Use `updateMany` and `deleteMany` for bulk mutations.

## Middleware for Logging and Soft-Delete

- Use Prisma middleware for cross-cutting concerns like logging:
  ```typescript
  prisma.$use(async (params, next) => {
    const before = Date.now();
    const result = await next(params);
    const after = Date.now();
    console.log(`${params.model}.${params.action} took ${after - before}ms`);
    return result;
  });
  ```
- Implement soft-delete with middleware:
  ```typescript
  prisma.$use(async (params, next) => {
    // Intercept delete and convert to soft-delete
    if (params.action === 'delete') {
      params.action = 'update';
      params.args['data'] = { deletedAt: new Date() };
    }
    if (params.action === 'deleteMany') {
      params.action = 'updateMany';
      if (params.args.data !== undefined) {
        params.args.data['deletedAt'] = new Date();
      } else {
        params.args['data'] = { deletedAt: new Date() };
      }
    }
    return next(params);
  });
  ```
- For Prisma 5+, prefer **client extensions** over middleware:
  ```typescript
  const prisma = new PrismaClient().$extends({
    query: {
      user: {
        async findMany({ args, query }) {
          args.where = { ...args.where, deletedAt: null };
          return query(args);
        },
        async delete({ args }) {
          return prisma.user.update({
            ...args,
            data: { deletedAt: new Date() },
          });
        },
      },
    },
  });
  ```

## Connection Management

- Configure connection pool size based on your environment:
  ```typescript
  const prisma = new PrismaClient({
    datasources: {
      db: {
        url: `${DATABASE_URL}?connection_limit=5&pool_timeout=10`,
      },
    },
  });
  ```
- Call `prisma.$disconnect()` in graceful shutdown handlers.
- In serverless environments, keep the connection pool small (1–5 connections).

## Logging and Debugging

- Enable query logging in development:
  ```typescript
  const prisma = new PrismaClient({
    log: ['query', 'info', 'warn', 'error'],
  });
  ```
- Use event-based logging for production monitoring:
  ```typescript
  const prisma = new PrismaClient({
    log: [{ emit: 'event', level: 'query' }],
  });

  prisma.$on('query', (e) => {
    console.log(`Query: ${e.query} — Duration: ${e.duration}ms`);
  });
  ```
